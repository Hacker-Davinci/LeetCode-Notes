直接 用 遞迴式 爆搜
![[Pasted image 20221202192253.png]]
```CPP
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return solve(m, n, m-1, n-1, dp);
    }
    int solve(int m, int n, int x, int y, vector<vector<int>> &dp){
        if(x < 0 || y < 0 || x >= m || y >= n) return 0;
        if(dp[x][y] != -1) return dp[x][y];
        if(x == 0 || y == 0) return dp[x][y] = 1;
        return dp[x][y] = solve(m, n, x-1, y, dp) + solve(m, n, x, y-1, dp);
    }
};
```
有障礙物的版本，稍微修改程式碼

![[Pasted image 20221202193002.png]]
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        int x = m-1, y = n-1;
        return solve(dp, grid, m, n, x, y);
    }
    int solve(vector<vector<int>> &dp, vector<vector<int>>& grid, int m, int n, int x, int y){
        if(x < 0 || y < 0 || x >= m || y >= n) return 0;
        if(dp[x][y] != -1) return dp[x][y];
        if(grid[x][y] == 1) return dp[x][y] = 0; // no possibility
        if(x == 0 && y == 0) return dp[x][y] = 1;
        return dp[x][y] = solve(dp, grid, m, n, x-1, y) + solve(dp, grid, m, n, x, y-1);
    }
};
```


to be solved: 980. Unique Paths III

