1143. Longest Common Subsequence
經典題目，第一次實作 LCS recursion top down 就上手
int m = s1.size();
int n = s2.size();
```cpp
if(s1[i] == s1[j]) dp[i][j] = 1 + dp[i-1][j-1];
else dp[i][j] = max(solve(i+1, j), solve(i, j+1)); 
class Solution {
public:
    // n^2
    int longestCommonSubsequence(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return solve(dp, s1, s2, m-1, n-1);
    }
    int solve(vector<vector<int>> &dp, string &s1, string &s2,  int i, int j){
        if(i < 0 || j < 0) return 0;
        if(dp[i][j] != -1) return dp[i][j];
        
        if(s1[i] == s2[j]) return dp[i][j] = 1 + solve(dp, s1, s2, i-1, j-1);
        return dp[i][j] = max(solve(dp, s1, s2, i, j-1), solve(dp, s1, s2, i-1, j));
    }
};
```
300. Longest Increasing Subsequence
遞迴式 不好想
每個value, 選或不選
遞迴式 
```cpp  O(N^2)
實作細節: 先用prev = -1 ，並讓第一個numver 可以被選 ，納入 if nums[cur] > nums[prev] 的狀況
dp[prev id][cur id] = max(dp[prev id][cur id+1], 1 + dp[cur id][cur id+1] ) if nums[cur] > nums[prev]
dp[prev id][cur id] = dp[prev id][cur id + 1] else
class Solution {
public:
    // dp[prev largest number index][cur number index]
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        int prev = -1; // implementation detail to show empty array
        int cur = 0;
       return solve(dp, nums, prev, cur, n);
    }
    int solve(vector<vector<int>> &dp, vector<int> &nums, int prev, int cur, int &n){
        if(cur == n) return 0; // the end
        // to check not empty and precomputed
        if(prev != -1 && dp[prev+1][cur] != -1) return dp[prev+1][cur]; 
        int taken = 0;
        if(prev == -1 || nums[prev] < nums[cur]) taken = 1 + solve(dp, nums, cur, cur+1, n);
        int not_taken = solve(dp, nums, prev, cur+1, n);
        return dp[prev+1][cur] = max(taken, not_taken);
    }
};
```

```cpp O(NlogN)
class Solution {
public:
    // dp[i th number][choose or not choose] = longest value
    int lengthOfLIS(vector<int>& nums) {
        vector<int> ans;
        for(auto &u: nums){
            auto it = lower_bound(ans.begin(), ans.end(), u);
            if(it == ans.end()) ans.push_back(u);
            else *it = u;
        }
        return ans.size();
    }
};
```

72.Edit Distance
```cpp
學習拆解 空字串，insert，del，replace 很重要
這可以讓你自己在沒想法的時候，找到一些線索

dp[i][j] = solve(i-1, j-1) if s1[i] == s2[j]
dp[i][j] = min({insert, del, replace});
insert  = 1 + solve(i, j-1) 將s1[i] 跟 s1[i+1] 之中 插入一個 s2[j]，所以 + 1
del  = 1 + solve(i-1, j) 將s1[i] 刪掉，所以 + 1
replace  = 1 + solve(i-1, j-1) 將s1[i] 替換成 s2[j]，所以 + 1
class Solution {
public:
    int minDistance(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return solve(dp, s1, s2, m-1, n-1);
    }
    int solve(vector<vector<int>> &dp, string &s1, string &s2, int i, int j){
        if(i < 0 || j < 0) return abs(i-j);
        if(dp[i][j] != -1) return dp[i][j];
        if(s1[i] == s2[j]) return 0 + solve(dp, s1, s2, i-1, j-1);
        
        int insert = 1 + solve(dp, s1, s2, i, j-1);
        int del = 1 + solve(dp, s1, s2, i-1, j);
        int replace = 1 + solve(dp, s1, s2, i-1, j-1);
        return dp[i][j] = min({insert, del, replace});
    }
};
```
115.Distinct Subsequences
```cpp
分為 match 跟 miss 兩種狀況
match 的話 ， 其實 也可以 選擇不 match，遞迴過去發現還解得出來，就 return 1
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return solve(dp, s, t, m-1, n-1);
    }
    int solve(vector<vector<int>> &dp, string &s, string &t, int i, int j){
        if(j < 0) return 1;
        if(i < 0) return 0;
        if(dp[i][j] != -1) return dp[i][j];
        int match = 0;
        if(s[i] == t[j]) match = solve(dp, s, t, i-1, j-1);
        int miss = solve(dp, s, t, i-1, j);
        return dp[i][j] = match + miss;
    }
};
```


647.Palindromic Substrings
```cpp

```
