knapsack topdown solution
```cpp
int main()
{
    dp = vector<vector<ll>>(2005, vector<ll>(2005, INT_MIN));
    cin >> capacity >> items;
    for(int i = 0; i < items; ++i){
        cin >> sizes[i] >> values[i];
    }
    cout << solve(0, capacity) << '\n';
    return 0;
}
ll solve(int item, int size){
    if(item >= items) return 0;
    if(dp[item][size] != INT_MIN) return dp[item][size];
    ll skip = solve(item+1, size);
    ll buy = 0;
    if(size-sizes[item] >= 0) // the important line easy to forget
       buy = values[item] + solve(item+1, size-sizes[item]);
    return dp[item][size] = max(skip, buy);
}
```

Some 0/1 knapsack problems :

->Subset sum  
->Equal sum partition  
->Count of subsets sum with a given sum  
->Minimum subset sum difference  
->Count the number of subset with a given difference  
->Target sum


198. House Robber
```cpp
class Solution {
public:

    // dp[day][rob or skip]
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size(), -1);
        int day = 0;
        return solve(dp, nums, day);
    }
    int solve(vector<int> &dp, vector<int> &nums, int day){
        if(day >= nums.size()) return 0;
        if(dp[day] != -1) return dp[day];
        int skip = solve(dp, nums, day+1);
        int transaction = nums[day] + solve(dp, nums, day+2);
      
        return dp[day] = max(skip, transaction);
    }
};
```
213. House Robber II
變成圓形，做兩遍即可
```cpp
class Solution {
public:
    // dp[day][buy or not]
    
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        vector<int> dp1(nums.size(), -1), dp2(nums.size(), -1);
        return max(solve(dp1, nums, nums.size()-1, 0), solve(dp2, nums, nums.size(), 1));
    }
    int solve(vector<int> &dp, vector<int> &nums, int end, int day){
        if(day >= end) return 0;
        if(dp[day] != -1) return dp[day];
        int skip = solve(dp, nums, end, day+1);
        int transaction = nums[day] + solve(dp, nums, end, day+2);

        return dp[day] = max(skip, transaction);
    }
};
```

337. House Robber III
![[Pasted image 20221202201012.png]]
```cpp
class Solution {
public:
    // dp[TrooNode*][choose or don't ]
    int rob(TreeNode* root) {
        unordered_map<TreeNode*, unordered_map<bool, int>> dp;
        bool buy = true;
        return solve(root, dp, buy);
    }
    // buy -> childrens or buy
    // don't buy -> childrens
    int solve(TreeNode* root, unordered_map<TreeNode*, unordered_map<bool, int>> &dp, bool buy){
        if(!root) return 0;
        if(dp[root].find(buy) != dp[root].end()) return dp[root][buy];
        if(!buy) return dp[root][buy] = solve(root->left, dp, !buy) + \
				         solve(root->right, dp, !buy);
        int skip = solve(root->left, dp, buy) + solve(root->right, dp, buy);
        int transaction = 0;
        if(buy){
            transaction = root->val + solve(root->left, dp, !buy) + \
			            solve(root->right, dp, !buy);
        }
        return dp[root][buy] = max(transaction, skip);    
    }
};
```



416. Partition Equal Subset Sum
可不可以組出該數字
其實本質上依然是 "選" 或 "不選" 的問題
只是用 子問題 求出 TRUE, FALSE 
```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int total = 0;
        for(auto &u: nums)
            total += u;
        if(total%2) return false;
        vector<vector<int>> dp(nums.size(), vector<int>(total/2+1, -1));
        int i = 0;
        int cur_sum = 0;
        int half = total/2;
        return solve(dp, nums, i, cur_sum, half) == 1;
    }
    
    int solve(vector<vector<int>> &dp, vector<int>& nums, int i, int cur_sum, int &target){
        if(i >= nums.size()) return 0;
        if(cur_sum > target) return 0;
        if(cur_sum == target) return 1;
        if(dp[i][cur_sum] != -1) return dp[i][cur_sum];
        
        bool result;
        result = solve(dp, nums, i+1, cur_sum, target) || \
			        solve(dp, nums, i+1, cur_sum + nums[i], target);
        return dp[i][cur_sum] = result;
    }
    
};

```
494. Target Sum
該數字被組合出來有幾種可能






