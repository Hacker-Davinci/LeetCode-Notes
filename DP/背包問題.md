knapsack topdown solution
```cpp
int main()
{
    dp = vector<vector<ll>>(2005, vector<ll>(2005, INT_MIN));
    cin >> capacity >> items;
    for(int i = 0; i < items; ++i){
        cin >> sizes[i] >> values[i];
    }
    cout << solve(0, capacity) << '\n';
    return 0;
}
ll solve(int item, int size){
    if(item >= items) return 0;
    if(dp[item][size] != INT_MIN) return dp[item][size];
    ll skip = solve(item+1, size);
    ll buy = 0;
    if(size-sizes[item] >= 0) // the important line easy to forget
       buy = values[item] + solve(item+1, size-sizes[item]);
    return dp[item][size] = max(skip, buy);
}
```

Some 0/1 knapsack problems :

->Subset sum  
->Equal sum partition  
->Count of subsets sum with a given sum  
->Minimum subset sum difference  
->Count the number of subset with a given difference  
->Target sum



494. Target Sum
該數字被組合出來有幾種可能
"在求解子問題的時候，遇到非常大的狀況"
// dp(num, id) = 在這個id 前的數字中， 可以組成此數字有多少個 ?

```cpp
dp[ith number][cur_sum] -> the combinations to reach target at the end
dpid][cur_sum] = dp[id+1][cur_sum] + dp[id+1][cur_sum+nums[id]]
class Solution {
public:
    
    int findTargetSumWays(vector<int>& nums, int target) {
        unordered_map<int, unordered_map<int, int>> dp;
        int id = 0;
        int cur_sum = 0;
        return solve(dp, nums, id, cur_sum, target);
    }
    int solve(unordered_map<int, unordered_map<int, int>> &dp, 
              vector<int> &nums, int id, int cur_sum, int target){
        if(id == nums.size()) return cur_sum == target;
        if(dp[id].find(cur_sum) != dp[id].end()) return dp[id][cur_sum];
        return dp[id][cur_sum] = solve(dp, nums, id+1, cur_sum+nums[id], target) + \
                                solve(dp, nums, id+1, cur_sum-nums[id], target);
    }
};
```




